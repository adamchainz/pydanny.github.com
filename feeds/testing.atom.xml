<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>pydanny</title><link href="http://pydanny.com/" rel="alternate"></link><link href="http://pydanny.com/feeds/testing.atom.xml" rel="self"></link><id>http://pydanny.com/</id><updated>2014-01-15T12:00:00-08:00</updated><entry><title>pytest: no-boilerplate testing</title><link href="http://pydanny.com/pytest-no-boilerplate-testing.html" rel="alternate"></link><updated>2014-01-15T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-15:pytest-no-boilerplate-testing.html</id><summary type="html">&lt;p&gt;When I first encountered Holger Krekel's &lt;a class="reference external" href="http://pytest.org/"&gt;pytest&lt;/a&gt; this summer on &lt;a class="reference external" href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/"&gt;Jeff Knupp's blog&lt;/a&gt; I felt like I had been living under a rock for years. I've been using Python's &lt;a class="reference external" href="http://docs.python.org/2/library/unittest.html"&gt;unittest&lt;/a&gt; framework since 2006 and &lt;a class="reference external" href="https://pypi.python.org/pypi/nose"&gt;nose&lt;/a&gt; to find tests since 2008, but here was another test framework dating back to at least &lt;a class="reference external" href="https://bitbucket.org/hpk42/pytest/commits/all?page=112"&gt;January 24, 2007&lt;/a&gt;.  &lt;strong&gt;pytest&lt;/strong&gt; is a very mature testing tool for testing Python. My favorite features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It can run &lt;strong&gt;unittest&lt;/strong&gt;, &lt;strong&gt;doctest&lt;/strong&gt;, and &lt;strong&gt;nose&lt;/strong&gt;, style tests suites, making it ideal for new and legacy projects.&lt;/li&gt;
&lt;li&gt;It includes an intuitively named &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; &lt;strong&gt;context manager&lt;/strong&gt; for testing exceptions.&lt;/li&gt;
&lt;li&gt;You can define &lt;cite&gt;fixture arguments&lt;/cite&gt; to generate baseline data. This is very, very different from Django-style fixtures.&lt;/li&gt;
&lt;li&gt;Via &lt;tt class="docutils literal"&gt;pytest.ini&lt;/tt&gt; you can change the behavior of pytest.&lt;/li&gt;
&lt;li&gt;Integrates nicely with &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Alright, lets dive into usage.&lt;/p&gt;
&lt;div class="section" id="test-discovery"&gt;
&lt;h2&gt;Test Discovery&lt;/h2&gt;
&lt;p&gt;The first thing that &lt;strong&gt;pytest&lt;/strong&gt; provides is test discovery. Like &lt;strong&gt;nose&lt;/strong&gt;, starting from the directory where it is run, it will find any Python module prefixed with &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt; and will attempt to run any defined &lt;strong&gt;unittest&lt;/strong&gt; or function prefixed with  &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt;. &lt;strong&gt;pytest&lt;/strong&gt; explores properly defined Python packages, searching recursively through directories that include &lt;tt class="docutils literal"&gt;__init.py__&lt;/tt&gt; modules. Since an image is probably easier to read, here's a sample directory structure annotated with which files are checked for tests:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;address/
    __init__.py
    envelope.py
    geo.py
    test_envelope.py &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
    test_geo.py &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
records/
    &lt;span class="c"&gt;# pytest WON&amp;#39;T look here because it lacks __init__.py&lt;/span&gt;
    records.csv
    records.py
    test_records.py &lt;span class="c"&gt;# skipped because records/ lacks __init__.py&lt;/span&gt;
__init__.py
main.py
test_main.py  &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I've explained which files are checked for tests, here is how &lt;strong&gt;pytest&lt;/strong&gt; determines what in each Python module is run as a test.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; &lt;em&gt;just runs&lt;/em&gt; &lt;strong&gt;doctests&lt;/strong&gt; and &lt;strong&gt;unittests&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; runs any function prefixed with &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt; as a test.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; does &lt;a class="reference external" href="http://pytest.org/latest/nose.html#unsupported-idioms-known-issues"&gt;it's best&lt;/a&gt; to run tests written for &lt;strong&gt;nose&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Yes, &lt;strong&gt;pytest&lt;/strong&gt; behaves similarly to &lt;strong&gt;nose&lt;/strong&gt; in test discovery. Next is another feature that it shares with &lt;strong&gt;nose&lt;/strong&gt; that I really enjoy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-tests-as-functions"&gt;
&lt;h2&gt;Writing Tests as Functions&lt;/h2&gt;
&lt;p&gt;Python's &lt;strong&gt;unittest&lt;/strong&gt; framework works, but it's always felt like too much boilerplate. I admit I like to write tests, but working with the &lt;strong&gt;unittest&lt;/strong&gt; framework always dimmed that fun. I suppose this is why the assert keyword is useful, because it changes this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;unittest&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TestMyStuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The former is nine lines of code (seven if you are using &lt;strong&gt;pytest&lt;/strong&gt; to find this test) to do what the assert statement does in one. However, the nine lines of &lt;strong&gt;unittest&lt;/strong&gt; code has a couple major advantages:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Not automatically run when stumbled on by the Python interpreter.&lt;/li&gt;
&lt;li&gt;Produces a more illuminating response than an uninformative &lt;cite&gt;AssertionError&lt;/cite&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fortunately, tools like &lt;strong&gt;pytest&lt;/strong&gt; (and &lt;strong&gt;nose&lt;/strong&gt;) provide the ability to write tests as functions. This means we can combine the advantages of both &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; thus:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we are down to just two lines of code! That could be increased to five if we called &lt;strong&gt;pytest&lt;/strong&gt; the same as we did in the &lt;strong&gt;unittest&lt;/strong&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next part is wonderful. If an &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement fails, then &lt;strong&gt;pytest&lt;/strong&gt; provides a very informative response. Let's check it out by running the following code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_gonna_fail&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# Going to fail here on line 4&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;When I run this code, I get the following response:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;====================&lt;/span&gt; &lt;span class="nv"&gt;FAILURES&lt;/span&gt; &lt;span class="o"&gt;=====================&lt;/span&gt;
----------------- test_gonna_fail -----------------

    def test_gonna_fail&lt;span class="o"&gt;()&lt;/span&gt;:
&amp;gt;       assert &lt;span class="nv"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; False
E       assert &lt;span class="nv"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; False

samples.py:4: &lt;span class="nv"&gt;AssertionError&lt;/span&gt;
&lt;span class="o"&gt;========&lt;/span&gt; 1 failed, 0 passed in 0.1 &lt;span class="nv"&gt;seconds&lt;/span&gt; &lt;span class="o"&gt;========&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, nose identified where the &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement failed on line 4 and displays exactly caused the failure (&lt;tt class="docutils literal"&gt;True&lt;/tt&gt; did not equal &lt;tt class="docutils literal"&gt;False&lt;/tt&gt;). Very nice indeed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-to-come"&gt;
&lt;h2&gt;More to Come&lt;/h2&gt;
&lt;p&gt;Come back to my blog tomorrow where I'll describe the following features of writing tests with &lt;strong&gt;pytest&lt;/strong&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; &lt;strong&gt;context manager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fixtures&lt;/li&gt;
&lt;li&gt;Teardown&lt;/li&gt;
&lt;li&gt;Integrating with Django&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="testing"></category></entry></feed>