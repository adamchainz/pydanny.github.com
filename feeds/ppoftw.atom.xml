<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>pydanny</title><link href="http://pydanny.com/" rel="alternate"></link><link href="http://pydanny.com/feeds/ppoftw.atom.xml" rel="self"></link><id>http://pydanny.com/</id><updated>2014-01-22T12:00:00-08:00</updated><entry><title>awesome-slugify: Human-readable URL slugs from any string (part 2)</title><link href="http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string-2.html" rel="alternate"></link><updated>2014-01-22T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-22:awesome-slugify-human-readable-url-slugs-from-any-string-2.html</id><summary type="html">&lt;p&gt;In my previous &lt;a class="reference external" href="http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string.html"&gt;blog post&lt;/a&gt; I covered using &lt;a class="reference external" href="https://pypi.python.org/pypi/awesome-slugify"&gt;awesome-slugify&lt;/a&gt; to capture slugs in both ASCII and unicode. Today I'm covering the definition custom language &lt;tt class="docutils literal"&gt;slugify&lt;/tt&gt; translation functions.&lt;/p&gt;
&lt;div class="section" id="defining-custom-language-slugify-translation-functions"&gt;
&lt;h2&gt;Defining Custom Language &lt;tt class="docutils literal"&gt;slugify&lt;/tt&gt; Translation Functions&lt;/h2&gt;
&lt;p&gt;For those times we need ASCII representation of unicode characters, we can't always use the default unicode-to-ASCII mappings. A powerful feature of &lt;strong&gt;awesome-slugify&lt;/strong&gt; is we can quickly and easily create our own translation functions. Just follow these two steps:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Define a translation dictionary. Keys are the names of things you want translated, and the associated values are what the keys are translated into.&lt;/li&gt;
&lt;li&gt;Generate a translation function using &lt;tt class="docutils literal"&gt;slugify.main.get_slugify()&lt;/tt&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Explaining this in depth will take paragraphs of text, so I'll just demonstrate it using &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Emoji"&gt;emoji&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c"&gt;# test_slugify_emoji.py&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="c"&gt;# Step 1: Define the translation dictionary&lt;/span&gt;
&lt;span class="n"&gt;ALT_EMOJI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ʘ‿ʘ&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;smiling&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ಠ_ಠ&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;disapproval&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;♥‿♥&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;enamored&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;♥&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;love&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# Step 2: Generate a translation function&lt;/span&gt;
&lt;span class="n"&gt;slugify_emoji&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pretranslate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ALT_EMOJI&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_basic_emoji&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_emoji&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;ʘ‿ʘ&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;smiling&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_emoji&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;ಠ_ಠ&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;disapproval&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_sentence&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;I ♥ Audrey Roy Greenfeld&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_emoji&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;I-love-Audrey-Roy-Greenfeld&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;img alt="I ♥ your unicode smile" class="align-center" id="i-your-unicode-smile" src="https://s3.amazonaws.com/pydanny/i-♥-your-unicode-smile.png" /&gt;
&lt;div class="section" id="more-practical-applications"&gt;
&lt;h3&gt;More Practical Applications&lt;/h3&gt;
&lt;p&gt;While writing an &lt;strong&gt;emoji&lt;/strong&gt;-based translation function is fun, most of the time we need more practical translation functions. Built into &lt;strong&gt;awesome-slugify&lt;/strong&gt; is a cyrillic translation function that works like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c"&gt;# test_slugify_cyrillic.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="c"&gt;# The following code is nearly identical to the source code of&lt;/span&gt;
&lt;span class="c"&gt;#   awesome-slugify. All credit goes to Dmitry Voronin.&lt;/span&gt;

&lt;span class="c"&gt;# Step 1: Define the translation dictionary&lt;/span&gt;
&lt;span class="n"&gt;ALT_CYRILLIC&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ё&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# instead of &amp;#39;io&amp;#39; / &amp;#39;yo&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ж&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;j&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# instead of &amp;#39;zh&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;у&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# instead of &amp;#39;u&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;х&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;h&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# instead of &amp;#39;kh&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;щ&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;sch&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c"&gt;# instead of &amp;#39;shch&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ю&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;    &lt;span class="c"&gt;# instead of &amp;#39;iu&amp;#39; / &amp;#39;yu&amp;#39;&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;я&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;ya&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;   &lt;span class="c"&gt;# instead of &amp;#39;ia&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# Step 2: Generate a translation function&lt;/span&gt;
&lt;span class="n"&gt;slugify_ru&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pretranslate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ALT_CYRILLIC&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_some_cyrillic&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;ж and я are really fun letters.&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_ru&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;j-and-ya-are-really-fun-letters&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://bikeshedder.com/"&gt;Michael P. Jung&lt;/a&gt; created a German translation function, which I've included below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c"&gt;# test_slugify_german.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="c"&gt;# Step 1: Define the translation dictionary&lt;/span&gt;
&lt;span class="n"&gt;ALT_GERMAN&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ä&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;ae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;Ä&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;Ae&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ö&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;oe&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;Ö&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;Oe&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;ü&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;ue&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;u&amp;#39;Ü&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;Ue&amp;#39;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# Step 2: Generate a translation function&lt;/span&gt;
&lt;span class="n"&gt;slugify_de&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pretranslate&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;ALT_GERMAN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_german_dumpling&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# According to Michael P. Jung, this looks like ice cream.&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_de&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;#39;Thüringer Klöße&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;Thueringer-Kloesse&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_german_road&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;I&amp;#39;ve never been in a car on a German straße&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_de&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;Ive-never-been-in-a-car-on-a-German-strasse&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;I really like the flexibility and power of &lt;strong&gt;awesome-slugify&lt;/strong&gt;. During slugification it provides functions to preserve unicode characters, convert unicode characters to ASCII, and even define new translation functions. As &lt;strong&gt;awesome-slugify&lt;/strong&gt; is a relatively new project, there are &lt;a class="reference external" href="https://github.com/dimka665/awesome-slugify/issues"&gt;a few issues&lt;/a&gt;, but most of those are for my quirky edge cases (such as when trying to use parenthesis in translation dictionaries for &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Emoticons"&gt;emoticons&lt;/a&gt;) or perhaps stem from my poor understanding of how unicode-to-ASCII functions.&lt;/p&gt;
&lt;p&gt;In any case, this is a very useful package.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2013/01/23&lt;/strong&gt; Thanks to &lt;a class="reference external" href="https://github.com/dimka665"&gt;Dmitry Voronin&lt;/a&gt;, I removed references to a couple issues with &lt;strong&gt;awesome-slugify&lt;/strong&gt;. It no longer forces capitalization in custom translation functions and the &lt;tt class="docutils literal"&gt;get_slugify()&lt;/tt&gt; can be imported directly from the base &lt;tt class="docutils literal"&gt;slugify&lt;/tt&gt; package.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="unicode"></category><category term="i18n"></category><category term="ppoftw"></category></entry><entry><title>awesome-slugify: Human-readable URL slugs from any string</title><link href="http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string.html" rel="alternate"></link><updated>2014-01-21T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-21:awesome-slugify-human-readable-url-slugs-from-any-string.html</id><summary type="html">&lt;p&gt;&lt;em&gt;note: The introduction mentions Django and Plone. However, this is not an article about Django or Plone.&lt;/em&gt;&lt;/p&gt;
&lt;div class="section" id="introduction"&gt;
&lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;Years ago, when I was working with &lt;a class="reference external" href="http://plone.org"&gt;Plone&lt;/a&gt; at &lt;a class="reference external" href="http://nasa.gov"&gt;NASA&lt;/a&gt;, one thing I dreaded was when content editors would copy-and-paste from Microsoft Word into the title bar. All kinds of funny characters would appear in the title bar and URL. I would have to go into the database (ZODB) and fix things. Things didn't get better until &lt;a class="reference external" href="https://github.com/reedobrien"&gt;Reed O'Brien&lt;/a&gt; turned on a title validator (probably in &lt;tt class="docutils literal"&gt;Plone.i18n&lt;/tt&gt;).&lt;/p&gt;
&lt;p&gt;When we started using &lt;a class="reference external" href="https://www.djangoproject.com"&gt;Django&lt;/a&gt;, one thing that made it nice was the presence of it's &lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/ref/utils/#module-django.utils.text"&gt;slugify()&lt;/a&gt; function and template filter. Inspired by the newspaper industry, this function it easier on both content editors and software engineers. In any case, using &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; we completed a number of projects, with &lt;a class="reference external" href="http://science.nasa.gov/"&gt;NASA Science&lt;/a&gt; being the only public one I worked on.&lt;/p&gt;
&lt;p&gt;As much as the &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; function was useful, there were problems. As I discovered time and time again over the years, it didn't handle &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Unicode"&gt;unicode&lt;/a&gt;. Or rather, it handled them by simply vanishing non-ASCII unicode characters. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;django.utils.text&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# German for road&lt;/span&gt;
&lt;span class="s"&gt;u&amp;quot;strae&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you read German, you'll know that the default Django &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; function is converting the word 'road' to nonsense. For sites dealing with internationalization, this won't do. So over three years ago while at &lt;a class="reference external" href="http://www.mozilla.org/"&gt;Mozilla&lt;/a&gt;, &lt;a class="reference external" href="http://pinterest.com"&gt;Pinterest&lt;/a&gt; engineer &lt;a class="reference external" href="https://twitter.com/davedash"&gt;Dave Dash&lt;/a&gt; created &lt;a class="reference external" href="https://pypi.python.org/pypi/unicode-slugify"&gt;unicode-slugify&lt;/a&gt;. From then on we could do this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# Again with the German word for road&lt;/span&gt;
&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="what-if-i-m-not-using-django"&gt;
&lt;h3&gt;What If I'm Not Using Django?&lt;/h3&gt;
&lt;p&gt;While a very nice tool, this package is dependent on Django's internal machinery to operate, which is a problem for non-Django users. While we could use Python's &lt;a class="reference external" href="http://flask.pocoo.org/snippets/5/"&gt;unicodedata library to resolve unicode to slugs&lt;/a&gt;, wouldn't it be nice if there was a nicely packaged/tested solution?&lt;/p&gt;
&lt;p&gt;Fortunately, such a nicely packaged/tested solution exists, and it's awesome!&lt;/p&gt;
&lt;img alt="An Awesome Django slug" class="align-center" id="django-slug" src="https://s3.amazonaws.com/pydanny/awesome_slugify_django.jpg" /&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="introducing-awesome-slugify"&gt;
&lt;h2&gt;Introducing awesome-slugify&lt;/h2&gt;
&lt;p&gt;Created and maintained by &lt;a class="reference external" href="https://github.com/dimka665"&gt;Dmitry Voronin&lt;/a&gt;, &lt;a class="reference external" href="https://pypi.python.org/pypi/awesome-slugify"&gt;awesome-slugify&lt;/a&gt; is easy to use and &lt;strong&gt;100% independent from Django&lt;/strong&gt;. You call it thus:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# Yet again the German for road&lt;/span&gt;
&lt;span class="s"&gt;u&amp;#39;strasse&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Works! Hooray!&lt;/p&gt;
&lt;p&gt;However, please note that unlike the Django-only &lt;strong&gt;unicode-slugify&lt;/strong&gt; package which preserves the non-ASCII characters, &lt;strong&gt;awesome-slugify&lt;/strong&gt; transformed the German 'ß' into an ASCII substitution of 'ss'. This is similar to how the popular &lt;a class="reference external" href="https://pypi.python.org/pypi/python-slugify"&gt;python-slugify&lt;/a&gt; package works. While this behavior of translating unicode to ASCII might work for English-only sites, it's not so useful for the rest of the world. Fortunately, &lt;strong&gt;awesome-slugify&lt;/strong&gt; also provides the incredibly useful &lt;tt class="docutils literal"&gt;slugify_unicode()&lt;/tt&gt; function:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# What is it with German Roads?&lt;/span&gt;
&lt;span class="s"&gt;u&amp;#39;stra&lt;/span&gt;&lt;span class="se"&gt;\xdf&lt;/span&gt;&lt;span class="s"&gt;e&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="using-awesome-slugify"&gt;
&lt;h3&gt;Using awesome-slugify&lt;/h3&gt;
&lt;p&gt;Rather than describe &lt;strong&gt;awesome-slugify&lt;/strong&gt; in paragraph format, here is working test code (&lt;a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing.html"&gt;using pytest which I described before&lt;/a&gt;) that explains what we can do:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c"&gt;# test_awesome_slugify.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_simple&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;This is basic functionality!!!    &amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;This-is-basic-functionality&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_remove_special_characters&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;special characters (#?@$%^&amp;amp;*) are also ASCII&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;special-characters-are-also-ASCII&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_basic_accents_and_backslash_escapes&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Where I&lt;/span&gt;&lt;span class="se"&gt;\&amp;#39;&lt;/span&gt;&lt;span class="s"&gt;ve gone before&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Where-Ive-gone-before&amp;quot;&lt;/span&gt;

&lt;span class="nd"&gt;@pytest.fixture&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;u&amp;#39;Àddîñg áçćèńtš tô Éñgłïśh íš śīłłÿ!&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_accents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Adding-accents-to-English-is-silly&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_keep_accents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; \
                        &lt;span class="s"&gt;&amp;#39;Àddîñg-áçćèńtš-tô-Éñgłïśh-íš-śīłłÿ&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_keep_accents_lower&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# Because awesome-slugify doesn&amp;#39;t lower() while slugify, we&lt;/span&gt;
    &lt;span class="c"&gt;#   have to do it ourselves. I&amp;#39;m torn if I like this or hate it&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;accents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; \
                        &lt;span class="s"&gt;&amp;#39;àddîñg-áçćèńtš-tô-éñgłïśh-íš-śīłłÿ&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_musical_notes&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Is ♬ ♫ ♪ ♩ a melody or just noise?&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Is-a-melody-or-just-noise&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Is-a-melody-or-just-noise&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_chinese&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;美国&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;# Chinese for &amp;#39;America&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Mei-Guo&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt;  &lt;span class="s"&gt;&amp;quot;美国&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_separator&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Separator is a word I frequently mispell.&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;separator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;capitalize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Separator_is_a_word_I_frequently_mispell&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Easy to use as any good &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; function!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="restricting-the-length-of-a-returned-slug"&gt;
&lt;h3&gt;Restricting the length of a returned slug&lt;/h3&gt;
&lt;p&gt;When using &lt;strong&gt;awesome-slugify&lt;/strong&gt;'s &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;slugify_unicode()&lt;/tt&gt; functions, the &lt;tt class="docutils literal"&gt;max_length&lt;/tt&gt; argument acts in an interesting fashion. On very short strings it removes longer words to make things fit. As the author of &lt;strong&gt;awesome-slugify&lt;/strong&gt; is Russian, and the Russian language, as far as I know, doesn't have prepositions (words like 'the' and 'a') this makes sense.&lt;/p&gt;
&lt;p&gt;Let's take a look, shall we?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="c"&gt;# test_awesome_slugify_max_length.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;slugify&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_max_length_tiny&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# Removes the longer words to fit smaller words in.&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$ is a special character, as is #.&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;is-a-as-is&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_max_length_medium&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# Keeps in prepositions, but removes meaningful words.&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;$ is a special character, as is #.&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;is-a-special-as&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_max_length_realistic&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# Long enough that long words are not removed from the string in favor&lt;/span&gt;
    &lt;span class="c"&gt;#   of shorter words.&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&amp;quot;This sentence illuminates the method that this package&lt;/span&gt;
&lt;span class="s"&gt;                handles truncation of longer strings.&lt;/span&gt;
&lt;span class="s"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; \
        &lt;span class="s"&gt;&amp;quot;This-sentence-illuminates-the-method-that-this-of&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# The next few tests cover how the max_length argument handles truncation&lt;/span&gt;
&lt;span class="c"&gt;#   inside of a word. When working with longer word languages, like German,&lt;/span&gt;
&lt;span class="c"&gt;#   understanding how your chosen slugify() function works is important.&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_truncating_word&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# This demonstrates taking a long German word and truncating it.&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;Rindfleischetikettierungsüberwachungsaufgabenübertragungsgesetz&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; \
                &lt;span class="s"&gt;&amp;quot;Rindfleischetikettierungsuberwachungsauf&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; \
                &lt;span class="s"&gt;u&amp;quot;Rindfleischetikettierungsüberwachungsauf&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_truncating_varying_letter_size&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# Truncating unicode slugs is challenging. For example, the German&lt;/span&gt;
    &lt;span class="c"&gt;#   letter &amp;#39;ß&amp;#39; is &amp;#39;ss&amp;#39; in English. Should a slugify&amp;#39;s max_length&lt;/span&gt;
    &lt;span class="c"&gt;#   argument use the German or the English length? In the case of&lt;/span&gt;
    &lt;span class="c"&gt;#   awesome-slugify, it uses the length of English letter for both the&lt;/span&gt;
    &lt;span class="c"&gt;#   slugify() and slugify_unicode() functions.&lt;/span&gt;
    &lt;span class="n"&gt;txt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;straße&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;# I really can&amp;#39;t stop using German roads.&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;stras&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;slugify_unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_length&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;straß&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's Next?&lt;/h2&gt;
&lt;p&gt;As demonstrated, &lt;strong&gt;awesome-slugify&lt;/strong&gt; covers many common use cases. Nevertheless, in &lt;a class="reference external" href="http://pydanny.com/awesome-slugify-human-readable-url-slugs-from-any-string-2.html"&gt;my next blog post&lt;/a&gt; I cover how to write custom language &lt;tt class="docutils literal"&gt;slugify()&lt;/tt&gt; translation functions using &lt;strong&gt;awesome-slugify&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2013/01/23&lt;/strong&gt; Thanks to &lt;a class="reference external" href="http://www.reddit.com/user/flying-sheep"&gt;flying-sheep&lt;/a&gt;, I Changed 'equivalent' to 'substitution' in describing the unicode-to-ASCII translation. This is because 'ss' is not a precise translation of 'ß'.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="unicode"></category><category term="i18n"></category><category term="ppoftw"></category></entry><entry><title>pytest: no-boilerplate testing (part 3)</title><link href="http://pydanny.com/pytest-no-boilerplate-testing-3.html" rel="alternate"></link><updated>2014-01-17T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-17:pytest-no-boilerplate-testing-3.html</id><summary type="html">&lt;p&gt;In my previous &lt;a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing-2.html"&gt;blog post&lt;/a&gt; I covered writing exception-based assertions and fixtures. Today I'm going to close things out by demonstrating how to change the behavior of &lt;a class="reference external" href="http://pytest.org/"&gt;pytest&lt;/a&gt; and how to integrate it with &lt;strong&gt;Django&lt;/strong&gt; and &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="changing-the-behavior-of-pytest"&gt;
&lt;h2&gt;Changing the Behavior of &lt;strong&gt;pytest&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;When &lt;strong&gt;pytest&lt;/strong&gt; is called, either via the command-line or by &lt;tt class="docutils literal"&gt;pytest.main()&lt;/tt&gt;, it &lt;a class="reference external" href="http://pytest.org/latest/customize.html#how-test-configuration-is-read-from-configuration-ini-files"&gt;looks for a configuration file&lt;/a&gt; called either &lt;tt class="docutils literal"&gt;pytest.ini&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;tox.ini&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;setup.cfg&lt;/tt&gt;. If it finds a configuration file, it follows standard practices for those things. In the following example, I demonstrating searching for tests inside of all Python files while ignoring the &lt;strong&gt;_build&lt;/strong&gt; directories:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;# pytest.ini (or tox.ini or setup.cfg)&lt;/span&gt;
&lt;span class="err"&gt;[pytest]&lt;/span&gt; &lt;span class="c1"&gt;# You must put pytest-related controls in a &amp;#39;pytest&amp;#39; block&lt;/span&gt;
&lt;span class="na"&gt;python_files&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;*.py  # Run tests against all python modules&lt;/span&gt;
&lt;span class="na"&gt;norecursedirs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;_build # Don&amp;#39;t look inside of _build directories&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="section" id="changing-pytest-behavior-dynamically"&gt;
&lt;h3&gt;Changing &lt;strong&gt;pytest&lt;/strong&gt; Behavior Dynamically&lt;/h3&gt;
&lt;p&gt;This is pretty nice, but if I need to ignore certain Python modules like &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;? I can do this by creating a &lt;tt class="docutils literal"&gt;conftest.py&lt;/tt&gt; module and defining a &lt;tt class="docutils literal"&gt;collect_ignore&lt;/tt&gt; variable.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# conftest.py&lt;/span&gt;
&lt;span class="n"&gt;collect_ignore&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;setup.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;conftest.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;conftest.py&lt;/tt&gt; module can actually be defined per directory. So if test behavior needs to change in different packages, just create additional &lt;tt class="docutils literal"&gt;conftest.py&lt;/tt&gt; modules. It's simple to do, but really powerful.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;conftest&lt;/tt&gt; module is capable of a lot of other things. Right now there doesn't seem to be a page that documents it in full, so I'm considering submitting a documentation pull request. In the meantime, I live off the &lt;tt class="docutils literal"&gt;conftest.py&lt;/tt&gt; &lt;a class="reference external" href="http://pytest.org/latest/search.html?q=conftest&amp;amp;check_keywords=yes&amp;amp;area=default"&gt;search results&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="pytest-is-plug-in-driven"&gt;
&lt;h3&gt;&lt;strong&gt;pytest&lt;/strong&gt; is Plug-In Driven&lt;/h3&gt;
&lt;p&gt;One feature I really like about &lt;strong&gt;pytest&lt;/strong&gt; is that much of it's default capabilities are driven by about 20 plug-ins. It's a sign of maturity that not only does it have plug-ins, but that most of the time this feature is transparent. You can add new plug-ins to your project in a &lt;a class="reference external" href="http://pytest.org/latest/plugins.html#plugin-discovery-order-at-tool-startup"&gt;number of ways&lt;/a&gt;, including &lt;tt class="docutils literal"&gt;pip&lt;/tt&gt; installation from &lt;a class="reference external" href="https://pypi.python.org/pypi/"&gt;PyPI&lt;/a&gt;. For locally defined plug-ins I prefer to rely on explicit &lt;tt class="docutils literal"&gt;conftest.py&lt;/tt&gt; declarations:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# conftest.py&lt;/span&gt;
&lt;span class="n"&gt;collect_ignore&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;setup.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;conftest.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;pytest_plugins&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;dream_plugin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;dream.utils.testplugin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are a lot of &lt;a class="reference external" href="https://pypi.python.org/pypi?%3Aaction=search&amp;amp;term=pytest-&amp;amp;submit=search"&gt;third-party pytest plug-ins&lt;/a&gt;, which brings me to the next major section: Integration with other tools and frameworks.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="django-integration-is-just-a-plug-in-away"&gt;
&lt;h2&gt;Django Integration is Just a Plug-In Away&lt;/h2&gt;
&lt;p&gt;If you want to use &lt;strong&gt;pytest&lt;/strong&gt; instead of &lt;strong&gt;Django&lt;/strong&gt;'s test runner and also get the power of function-based tests, fixture functions, improved test discover, and all the stuff I haven't covered, then check out and/or &lt;tt class="docutils literal"&gt;pip&lt;/tt&gt; install &lt;a class="reference external" href="https://pypi.python.org/pypi/pytest-django"&gt;pytest-django&lt;/a&gt;. My &lt;em&gt;admittedly brief&lt;/em&gt; usage on some of my existing projects has demonstrating that my existing &lt;strong&gt;unittest&lt;/strong&gt;-style tests work.&lt;/p&gt;
&lt;p&gt;That previous tests still function means that as with a pure Python project, I can rely on existing &lt;strong&gt;unittests&lt;/strong&gt; and write all my new tests as functions. I guess I could say that my existing Django projects just got much easier to maintain.&lt;/p&gt;
&lt;p&gt;A good example of using &lt;strong&gt;pytest&lt;/strong&gt; with &lt;strong&gt;Django&lt;/strong&gt; can be found in &lt;a class="reference external" href="https://github.com/brack3t/django-braces/blob/master/tox.ini"&gt;django-braces' tox.ini file&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="twisted-and-more-integration-is-just-a-plug-in-away"&gt;
&lt;h3&gt;Twisted (and more) Integration is Just a Plug-In Away&lt;/h3&gt;
&lt;p&gt;The same goes for &lt;a class="reference external" href="http://twistedmatrix.com/"&gt;Twisted&lt;/a&gt; thanks to &lt;a class="reference external" href="https://pypi.python.org/pypi/pytest-twisted"&gt;pytest-twisted&lt;/a&gt;. There is also a &lt;a class="reference external" href="http://www.pylonsproject.org/"&gt;Pyramid&lt;/a&gt; plug-in that was just &lt;a class="reference external" href="https://pypi.python.org/pypi/pytest_pyramid"&gt;released&lt;/a&gt;. I'm not sure if &lt;a class="reference external" href="http://flask.pocoo.org/"&gt;Flask&lt;/a&gt; needs it, but I guess there will be &lt;strong&gt;Flask&lt;/strong&gt; plug-in soon.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="integration-with-setup-py"&gt;
&lt;h2&gt;Integration With &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;&lt;/h2&gt;
&lt;p&gt;Fortunately, the documentation for &lt;strong&gt;pytest&lt;/strong&gt; covers both adding a new &lt;a class="reference external" href="http://pytest.org/latest/goodpractises.html#integrating-with-distutils-python-setup-py-test"&gt;setup.py command-classes for pytest&lt;/a&gt; and &lt;a class="reference external" href="http://pytest.org/latest/goodpractises.html#integration-with-setuptools-test-commands"&gt;actual integration&lt;/a&gt;. That's handy, but what I've found even more useful is the &lt;a class="reference external" href="https://github.com/jeffknupp/sandman/blob/develop/setup.py"&gt;setup.py that Jeff Knupp wrote for his Sandman project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; If you aren't experienced with writing Python packages and readying them for &lt;strong&gt;PyPI&lt;/strong&gt;, I recommend you read &lt;a class="reference external" href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/"&gt;Jeff Knupp's blog post on open sourcing projects&lt;/a&gt;. Amongst other things, it has an in-depth discussion about integration of &lt;strong&gt;pytest&lt;/strong&gt; with &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;. Anything I would write on the subject of &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt; integration would be just a cheap knock-off of Jeff's excellent work.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;Tests are an important part of any project. While they increase the stability of a project, that unfortunately can come at the cost of the boredom of writing tests. Fortunately, &lt;strong&gt;pytest&lt;/strong&gt; goes a long way to alleviating that boredom while also empowering Python code authors with lots of additional useful tools. I'm delighted to have finally discovered &lt;strong&gt;pytest&lt;/strong&gt;. In the short time I've used &lt;strong&gt;pytest&lt;/strong&gt;, it's saved me days, if not weeks, of tedious work.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="testing"></category><category term="ppoftw"></category></entry><entry><title>pytest: no-boilerplate testing (part 2)</title><link href="http://pydanny.com/pytest-no-boilerplate-testing-2.html" rel="alternate"></link><updated>2014-01-16T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-16:pytest-no-boilerplate-testing-2.html</id><summary type="html">&lt;p&gt;In my previous &lt;a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing.html"&gt;blog post&lt;/a&gt; I covered test discovery and writing basic tests using &lt;a class="reference external" href="http://pytest.org/"&gt;pytest&lt;/a&gt;. Today I'm going to cover a few more features that I really enjoy: &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;fixtures&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="section" id="the-intuitively-named-raises-context-manager"&gt;
&lt;h2&gt;The Intuitively Named &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; &lt;strong&gt;context manager&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;When using &lt;strong&gt;pytest&lt;/strong&gt;, you can assert whether or not an exception occurred via the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# test_exceptions.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;raises&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_an_exception&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;raises&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;IndexError&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="c"&gt;# Indexing the 30th item in a 3 item list&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CustomException&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_my_exception&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;raises&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CustomException&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;CustomException&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is similar to, but just a bit easier to remember than the implementation in &lt;a class="reference external" href="http://docs.python.org/2/library/unittest.html"&gt;unittest&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;What I like about it is that even if I step away from code and tests for enough time to go on vacation and &lt;a class="reference external" href="http://pydanny.com/i-married-audrey-roy.html"&gt;get married&lt;/a&gt;, when I come back I always remember the precise name of the &lt;strong&gt;context manager&lt;/strong&gt; used to raise exceptions.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="fixtures-as-function-arguments"&gt;
&lt;h2&gt;Fixtures as Function Arguments&lt;/h2&gt;
&lt;p&gt;When writing tests, it's not uncommon to need common objects used between tests. However, if you have a complicated process to generate these common objects, then you have to write tests for your tests. When using Python's venerable &lt;strong&gt;unittest&lt;/strong&gt; framework, this always causes a spaghetti-code headache. However, via the virtue of simplicity, &lt;strong&gt;pytest&lt;/strong&gt; helps keep our test code cleaner and more maintainable.&lt;/p&gt;
&lt;p&gt;Rather than try and explain that further, I'll write some code to get my point across:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# test_fixtures.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;fixture&lt;/span&gt;

&lt;span class="nd"&gt;@fixture&lt;/span&gt;  &lt;span class="c"&gt;# Registering this function as a fixture.&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;complex_data&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c"&gt;# Creating test data entirely in this function to isolate it&lt;/span&gt;
    &lt;span class="c"&gt;#   from the rest of this module.&lt;/span&gt;
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DataTypes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;
        &lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;DataTypes&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_types&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;# fixture is passed as an argument&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Elephant&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nice and simple, which is how I think test harnesses should operate.&lt;/p&gt;
&lt;div class="section" id="writing-tests-for-fixtures"&gt;
&lt;h3&gt;Writing Tests for Fixtures&lt;/h3&gt;
&lt;p&gt;Let's pretend that the &lt;tt class="docutils literal"&gt;complex_data()&lt;/tt&gt; is a terribly sophisticated function in it's own right. It's so sophisticated that I can't determine what it's actually doing, and I start to get worried. Fortunately, because the &lt;tt class="docutils literal"&gt;complex_data()&lt;/tt&gt; argument itself is written as a function, I can easily write a test for it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# test_fixtures.py&lt;/span&gt;
&lt;span class="c"&gt;# note: this version of test_fixtures.py is built off the previous example&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_complex_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;complex_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I can easily write tests for my fixtures, that means I can refactor them! I can replace difficult-to-use libraries with easier ones, break up giant functions into little ones, and generally simplify the unnecessarily complex.&lt;/p&gt;
&lt;p&gt;If you've ever been in that weird place where a &lt;strong&gt;unittest&lt;/strong&gt; &lt;tt class="docutils literal"&gt;setUp()&lt;/tt&gt; method is indecipherable, you know just how useful this can be.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="scoping-fixtures"&gt;
&lt;h3&gt;Scoping Fixtures&lt;/h3&gt;
&lt;p&gt;What if I want a fixture that shares it's scope across several test functions?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# test_fixtures_with_scope.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;fixture&lt;/span&gt;

&lt;span class="nd"&gt;@fixture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scope&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;module&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# Registering fixture with module-level scope&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_first&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="n"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_second&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;scope_data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;count&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="executing-teardown-code"&gt;
&lt;h3&gt;Executing Teardown Code&lt;/h3&gt;
&lt;p&gt;I can tear down data structures in them. This is useful for any sort of data binding, including file management.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# test_fixtures_with_teardown.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;fixture&lt;/span&gt;

&lt;span class="nd"&gt;@fixture&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;file_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="c"&gt;# The fixture MUST have a &amp;#39;request&amp;#39; argument&lt;/span&gt;
    &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;data.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;w&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@request.addfinalizer&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;teardown&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_data_type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file_data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;file_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What's really nice about this teardown feature is that when combined with the fixture decorator's &lt;tt class="docutils literal"&gt;scope&lt;/tt&gt; argument, I can exactly control when fixtures are taken down. This is an amazing piece of control. While I can and have duplicated this behavior using &lt;strong&gt;unittest&lt;/strong&gt;, with &lt;strong&gt;pytest&lt;/strong&gt; I can do it with more obvious code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="more-pytext-fixture-features"&gt;
&lt;h3&gt;More &lt;strong&gt;pytext&lt;/strong&gt; Fixture Features&lt;/h3&gt;
&lt;p&gt;Want to know more things you can do with &lt;strong&gt;pytest&lt;/strong&gt; fixtures? Please read the &lt;a class="reference external" href="http://pytest.org/latest/fixture.html"&gt;pytest fixtures documentation&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="more-to-come"&gt;
&lt;h2&gt;More to Come&lt;/h2&gt;
&lt;p&gt;In my &lt;a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing-3.html"&gt;next blog post&lt;/a&gt; I describe usage of the following &lt;strong&gt;pytest&lt;/strong&gt; features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Changing behavior of &lt;strong&gt;pytest&lt;/strong&gt; with &lt;tt class="docutils literal"&gt;pytest.ini&lt;/tt&gt; and plug-ins.&lt;/li&gt;
&lt;li&gt;Integration with &lt;strong&gt;Django&lt;/strong&gt; and other frameworks.&lt;/li&gt;
&lt;li&gt;Integration with &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="testing"></category><category term="ppoftw"></category></entry><entry><title>pytest: no-boilerplate testing</title><link href="http://pydanny.com/pytest-no-boilerplate-testing.html" rel="alternate"></link><updated>2014-01-15T12:00:00-08:00</updated><author><name>Daniel-Greenfeld</name></author><id>tag:pydanny.com,2014-01-15:pytest-no-boilerplate-testing.html</id><summary type="html">&lt;p&gt;When I first encountered Holger Krekel's &lt;a class="reference external" href="http://pytest.org/"&gt;pytest&lt;/a&gt; this summer on &lt;a class="reference external" href="http://www.jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/"&gt;Jeff Knupp's blog&lt;/a&gt; I felt like I had been living under a rock for years. I've been using Python's &lt;a class="reference external" href="http://docs.python.org/2/library/unittest.html"&gt;unittest&lt;/a&gt; framework since 2006 and &lt;a class="reference external" href="https://pypi.python.org/pypi/nose"&gt;nose&lt;/a&gt; to find tests since 2008, but here was another test framework that actually predates &lt;strong&gt;nose&lt;/strong&gt;!  &lt;strong&gt;pytest&lt;/strong&gt; is a very mature testing tool for testing Python. My favorite features:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;It can run &lt;strong&gt;unittest&lt;/strong&gt;, &lt;strong&gt;doctest&lt;/strong&gt;, and &lt;strong&gt;nose&lt;/strong&gt;, style tests suites, making it ideal for new and legacy projects.&lt;/li&gt;
&lt;li&gt;It includes an intuitively named &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; &lt;strong&gt;context manager&lt;/strong&gt; for testing exceptions.&lt;/li&gt;
&lt;li&gt;You can define &lt;cite&gt;fixture arguments&lt;/cite&gt; to generate baseline data. This is very, very different from Django-style fixtures.&lt;/li&gt;
&lt;li&gt;Via &lt;tt class="docutils literal"&gt;pytest.ini&lt;/tt&gt; you can change the behavior of pytest.&lt;/li&gt;
&lt;li&gt;Integrates nicely with &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Alright, lets dive into usage.&lt;/p&gt;
&lt;div class="section" id="test-discovery"&gt;
&lt;h2&gt;Test Discovery&lt;/h2&gt;
&lt;p&gt;The first thing that &lt;strong&gt;pytest&lt;/strong&gt; provides is test discovery. Like &lt;strong&gt;nose&lt;/strong&gt;, starting from the directory where it is run, it will find any Python module prefixed with &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt; and will attempt to run any defined &lt;strong&gt;unittest&lt;/strong&gt; or function prefixed with  &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt;. &lt;strong&gt;pytest&lt;/strong&gt; explores properly defined Python packages, searching recursively through directories that include &lt;tt class="docutils literal"&gt;__init__.py&lt;/tt&gt; modules. Since an image is probably easier to read, here's a sample directory structure annotated with which files are checked for tests:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;address/
    __init__.py
    envelope.py
    geo.py
    test_envelope.py &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
    test_geo.py &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
records/
    &lt;span class="c"&gt;# pytest WON&amp;#39;T look here because it lacks __init__.py&lt;/span&gt;
    records.csv
    records.py
    test_records.py &lt;span class="c"&gt;# skipped because records/ lacks __init__.py&lt;/span&gt;
__init__.py
main.py
test_main.py  &lt;span class="c"&gt;# checked for tests&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now that I've explained which files are checked for tests, here is how &lt;strong&gt;pytest&lt;/strong&gt; determines what in each Python module is run as a test.&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; &lt;em&gt;just runs&lt;/em&gt; &lt;strong&gt;doctests&lt;/strong&gt; and &lt;strong&gt;unittests&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; runs any function prefixed with &lt;tt class="docutils literal"&gt;test_&lt;/tt&gt; as a test.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pytest&lt;/strong&gt; does &lt;a class="reference external" href="http://pytest.org/latest/nose.html#unsupported-idioms-known-issues"&gt;it's best&lt;/a&gt; to run tests written for &lt;strong&gt;nose&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Yes, &lt;strong&gt;pytest&lt;/strong&gt; behaves similarly to &lt;strong&gt;nose&lt;/strong&gt; in test discovery. Next is another feature that it shares with &lt;strong&gt;nose&lt;/strong&gt; that I really enjoy.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="writing-tests-as-functions"&gt;
&lt;h2&gt;Writing Tests as Functions&lt;/h2&gt;
&lt;p&gt;Python's &lt;strong&gt;unittest&lt;/strong&gt; framework works, but it's always felt like too much boilerplate. I admit I like to write tests, but working with the &lt;strong&gt;unittest&lt;/strong&gt; framework always dimmed that fun. I suppose this is why the assert keyword is useful, because it changes this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;unittest&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TestMyStuff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;TestCase&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assertEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;unittest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The former is nine lines of code (seven if you are using &lt;strong&gt;pytest&lt;/strong&gt; to find this test) to do what the assert statement does in one. However, the nine lines of &lt;strong&gt;unittest&lt;/strong&gt; code has a couple major advantages:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Not automatically run when stumbled on by the Python interpreter.&lt;/li&gt;
&lt;li&gt;Produces a more illuminating response than an uninformative &lt;cite&gt;AssertionError&lt;/cite&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Fortunately, tools like &lt;strong&gt;pytest&lt;/strong&gt; (and &lt;strong&gt;nose&lt;/strong&gt;) provide the ability to write tests as functions. This means we can combine the advantages of both &lt;tt class="docutils literal"&gt;unittest&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; thus:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we are down to just two lines of code! That could be increased to five if we called &lt;strong&gt;pytest&lt;/strong&gt; the same as we did in the &lt;strong&gt;unittest&lt;/strong&gt; example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_the_obvious&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The next part is wonderful. If an &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement fails, then &lt;strong&gt;pytest&lt;/strong&gt; provides a very informative response. Let's check it out by running the following code:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt;1
2
3
4
5
6
7&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;pytest&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_gonna_fail&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;  &lt;span class="c"&gt;# Going to fail here on line 4&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;pytest&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;When I run this code, I get the following response:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;====================&lt;/span&gt; &lt;span class="nv"&gt;FAILURES&lt;/span&gt; &lt;span class="o"&gt;=====================&lt;/span&gt;
----------------- test_gonna_fail -----------------

    def test_gonna_fail&lt;span class="o"&gt;()&lt;/span&gt;:
&amp;gt;       assert &lt;span class="nv"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; False
E       assert &lt;span class="nv"&gt;True&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; False

samples.py:4: &lt;span class="nv"&gt;AssertionError&lt;/span&gt;
&lt;span class="o"&gt;========&lt;/span&gt; 1 failed, 0 passed in 0.1 &lt;span class="nv"&gt;seconds&lt;/span&gt; &lt;span class="o"&gt;========&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, pytest identified where the &lt;tt class="docutils literal"&gt;assert&lt;/tt&gt; statement failed on line 4 and displays exactly caused the failure (&lt;tt class="docutils literal"&gt;True&lt;/tt&gt; did not equal &lt;tt class="docutils literal"&gt;False&lt;/tt&gt;). Very nice indeed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's Next?&lt;/h2&gt;
&lt;p&gt;In my next &lt;a class="reference external" href="http://pydanny.com/pytest-no-boilerplate-testing-2.html"&gt;blog post&lt;/a&gt; I describe the following features of writing tests with &lt;strong&gt;pytest&lt;/strong&gt;.&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;The &lt;tt class="docutils literal"&gt;raises&lt;/tt&gt; &lt;strong&gt;context manager&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Fixtures&lt;/li&gt;
&lt;li&gt;Fixture Teardown&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="testing"></category><category term="ppoftw"></category></entry></feed>